<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>RSA小学生(1)</title>
      <link href="/2022/07/21/rsa-xiao-xue-sheng-1/"/>
      <url>/2022/07/21/rsa-xiao-xue-sheng-1/</url>
      
        <content type="html"><![CDATA[<h1 id="RSA小学生-1"><a href="#RSA小学生-1" class="headerlink" title="RSA小学生(1)"></a>RSA小学生(1)</h1><p>​        这是我之前发现的一个网站，里面是一个大佬原创的一系列RSA基础题目。<br>​        网址：<a href="http://162.14.73.60:18000/challenges">http://162.14.73.60:18000/challenges</a></p><h2 id="RSA1："><a href="#RSA1：" class="headerlink" title="RSA1："></a>RSA1：</h2><p>​        题目给出了出题的脚本，关键是e = 1，根据rsa的加密解密公式:m^e = c (mod n),可以得到这里的m = c,所以可以直接得到答案。</p><h2 id="RSA2"><a href="#RSA2" class="headerlink" title="RSA2:"></a>RSA2:</h2><p>​        题目中还是e = 1,所以处理方式还是和上面的一样，但是结果却出了一堆乱码，所以说明了这次的m是大于n的，但是尝试爆破，很难爆破出来，所以有别的思路，用中国剩余定理可以得到m。<br>​        中国剩余定理的函数在python可以自己写.</p><pre class="language-none"><code class="language-none">from functools import reducedef CRT(mi, ai):    # mi,ai分别表示模数和取模后的值,都为列表结构    # Chinese Remainder Theorem    assert (isinstance(mi, list) and isinstance(ai, list))    M = reduce(lambda x, y: x * y, mi)    ai_ti_Mi = [a * (M // m) * gmpy2.invert(M // m, m) for (m, a) in zip(mi, ai)]    return reduce(lambda x, y: x + y, ai_ti_Mi) % M</code></pre><h4 id="RSA3"><a href="#RSA3" class="headerlink" title="RSA3:"></a>RSA3:</h4><p>​        题目中给了两组公钥和密文，因为n两组n相等，所以首先判断是共模攻击，数学思想为：<br>$$<br>证明: m = c1^s1 *c2^s2%n<br>$$</p><p>$$<br>m = c^d (mod n)<br>$$</p><p>$$<br>c1 = m^e1( mod n)<br>$$</p><p>$$<br>c2 = m^e2( mod n)<br>$$</p><p>$$<br>得：c1^s1 <em>c2^s2//n = [(m^e1)^s1//n</em>(m^e2)^s2//n]//n<br>$$</p><p>$$<br>化简得: c1^s1 <em>c2^s2%n = [(m^e1)^s1</em>(m^e2)^s2]%n<br>                      = [(m^e1s1+e2s2]%n<br>                      = m%n<br>                      = m<br>$$</p><p>​        s由拓展欧几里得得到，满足e1s1+e2s2 = gcd(e1,e2)</p><h4 id="RSA4"><a href="#RSA4" class="headerlink" title="RSA4:"></a>RSA4:</h4><p>​        题目给了两个压缩包，格式都是.enc，所以在python中用open(,’rb’)read()将其打开解读，拿到了n,e,c尝试分解n，不成功，看到题目，尝试将c分解，成功了，所以c和n互换，开始解题，结果出错了，再看题，给错密钥了，尝试直接将d打印出来，成功了.</p><h4 id="RSA5"><a href="#RSA5" class="headerlink" title="RSA5:"></a>RSA5:</h4><p>​        和第四题一样将文件解读出来，使用yafu将n分解，得到flag。</p><h4 id="RSA6"><a href="#RSA6" class="headerlink" title="RSA6:"></a>RSA6:</h4><p>​        题目名称是听说过OEAP吗，这是一种对于密文的填充方式，需要新的函数解读。还是先想之前的一样，将文件打开，找到公钥，并用yafu将n分解得到p和q之后开始正常解题，结果果然还是不行，于是开始再次解读c。<br>​        引入</p><pre class="language-none"><code class="language-none">import Crypto.Cipher.PKCS1_OAEP as OAEPkey = RSA.construct((p*q,e,int(gmpy2.invert(e,phi))))rsa = OAEP.new(key)print(rsa.decrypt(c))</code></pre><p>​        完成对于密文的解密。</p><h4 id="RSA7："><a href="#RSA7：" class="headerlink" title="RSA7："></a>RSA7：</h4><p>​        题中很明显的一个特点是e很大，参考维纳攻击，可以完成爆破。<br>​        维纳攻击主要是依靠连分数和渐进分数，主要数学思想如下<br>$$<br>p和q是很大的素数，则(p-1)<em>(q-1)无限趋近于p</em>q.<br>$$</p><p>$$<br>ed = 1 (mod φ(n))<br>$$</p><p>$$<br>ed = kφ(n) + 1,两边同时除以dφ(n)得到：<br>$$</p><p>$$<br>e/φ(n) = k/d +1/dφ(n)<br>$$</p><p>$$<br>≈ e/n = k/d +1/dφ(n)<br>$$</p><p>$$<br>所以k/d一定在是e/n的渐进分数之一,之后可以将d爆破出来<br>$$</p><h4 id="RSA8"><a href="#RSA8" class="headerlink" title="RSA8:"></a>RSA8:</h4><p>​        奇怪的N？N怪在哪里，不知道，但还是先将其分解试试，明白了，N奇怪在不可分解，但这样就没有思路了，题目只给了n，e，c，所以我尝试将n直接当成q*1来使用，也就是说q = n,p = 1，最终解出答案。</p><h4 id="RSA9："><a href="#RSA9：" class="headerlink" title="RSA9："></a>RSA9：</h4><p>​        说好了，摊牌了，所以我就直接试了试，结果除了一堆乱码，又想到他说的摊牌可能是直接将明文给出来了，所以我要找下c，结果确实，他摊牌了，啥都招了。</p><h4 id="RSA10："><a href="#RSA10：" class="headerlink" title="RSA10："></a>RSA10：</h4><p>​        这道题给了两组数据，没有什么关联的，所以这道题应该是让我去找关联。尝试进行数学分析。先尝试直接求解，结果出了一堆乱码，再尝试使用中国剩余定理，结果还是一堆乱码，继续转变思路，尝试将两组数据当成一组处理，只是这样的话，可以得到除了明文和密文之外的所有数据，但需重新找到c，这里可以使用中国剩余定理，最终结出明文。</p><h4 id="RSA11："><a href="#RSA11：" class="headerlink" title="RSA11："></a>RSA11：</h4><p>​        题目中e = 3，先想到爆破，最终爆破出答案。</p><h4 id="RSA12："><a href="#RSA12：" class="headerlink" title="RSA12："></a>RSA12：</h4><p>​        题目中给出中国剩余定理的提示，但又在问e是多少，所以这道题应该是要将e爆破出来的,题目给出了e的范围是（10，20），e为素数所以也很好爆破。</p><h4 id="RSA13："><a href="#RSA13：" class="headerlink" title="RSA13："></a>RSA13：</h4><p>​        本题给了两组N和C也给了e，根据出题的脚本，两组N之间存在一个公因数p，可以现将p和q1，q2求出来，最终得到了两组数据，分别求解，c1和c2分别是flag的一半。</p><h4 id="RSA14："><a href="#RSA14：" class="headerlink" title="RSA14："></a>RSA14：</h4><p>​        dp泄露，给出了e，解题的数学思想如下：<br>$$<br>dp = d (mod (p-1))<br>$$</p><p>$$<br>edp = ed (mod(p-1))<br>$$</p><p>$$<br>ed = 1 (modφ(n))<br>$$</p><p>$$<br>ed = 1(mod(p-1))<br>$$</p><p>$$<br>edp = 1(mod(p-1))<br>$$</p><p>$$<br>edp - 1 = k(p-1)<br>$$</p><p>$$<br>2^(edp-1) = 2^k(p-1)=1(modp)<br>$$</p><p>$$<br>2^(edp-1) - 1 = tp<br>$$</p><p>$$<br>所以2^(edp-1) - 1和n之间存在公因数p，p可以直接求出来。<br>$$</p><p>​        也可以通过爆破k的方式来求解p，具体是edp&gt;k(p-1),dp&lt;p-1,e&gt;k.依靠函数libnum.prime_test()判断p是否为素数，来达到目的。</p><h4 id="RSA15："><a href="#RSA15：" class="headerlink" title="RSA15："></a>RSA15：</h4><p>​        dp和dq泄露，都有但是没有e所以思路应该和上面拿到题有所区别，数学思路如下：<br>$$<br>m = c^d (mod n)<br>$$</p><p>$$<br>设mp = c^d(mod p),mq = c^d(modq)<br>$$</p><p>$$<br>dp = d(mod(p-1),dq = d(mod(p-1)<br>$$</p><p>$$<br>所以dp = d + k(p-1),dq = d + k(q-1)<br>$$</p><p>$$<br>c^d = c^dp(mod n),c^d = c^dq(mod n)<br>$$</p><p>$$<br>c^d = mp + tp<br>$$</p><p>$$<br>mq = (mp+tp) (modq)<br>$$</p><p>$$<br>mq - mp = tp(modq)<br>$$</p><p>$$<br>(mq-mp)p^-1 = t (modq)<br>$$</p><p>$$<br>t = (mq-mp)p^-1  (modq)<br>$$</p><p>$$<br>则c^d = mp + ((mq-mp)p^-1  (modq))<br>$$</p><p>$$<br>m = mp + p*((mq-mp)p^-1  (modq))(mod n)<br>$$</p><p>​        右边的数据全部已知，所以m就已知。</p><h4 id="RSA16："><a href="#RSA16：" class="headerlink" title="RSA16："></a>RSA16：</h4><p>​        题目让分解n，那就先用yafu分解n试试，结果出了5个因数，但还是按常规思路去解题。结果却是乱码，再次仔细看题目，发现n分解的5个因数全部相等，那么n的欧拉函数的求解就要用别的方法了。<br>欧拉定理:<br>$$<br>1.当n为1时，φ(1)=1。因为1与任何数都构成互质关系<br>$$</p><p>$$<br>2.当n为质数时，φ(n)=n−1。因为质数与小于它的每一个数都互质。<br>$$</p><p>$$<br>3.当n为质数的次方时n=p^k，则φ(n)=p^k−p^(k−1)=p^(k-1)*(p-1).<br>$$</p><p>$$<br>4.当n为两个互质的数之积n=p⋅q, 则φ(n)=φ(p)φ⋅(q).<br>$$</p><p>$$<br>5.任意一个大于1的正整数n，都可以写成一系列质数的积n=p^k1*p^k2⋯p^kr<br>$$</p><h4 id="RSA17"><a href="#RSA17" class="headerlink" title="RSA17:"></a>RSA17:</h4><p>​        好像什么都说了，但尝试将q解出来后，发现q不是素数，将q分解后发现q可以分解成3个相等的因数，所以这道题又回到了φ(n)的求解上来了，明白了这些之后，flag就直接出来了。</p><h4 id="RSA18："><a href="#RSA18：" class="headerlink" title="RSA18："></a>RSA18：</h4><p>​        题目有问题，什么问题？e好像不是素数，处理的方式和之前思想相同，m^e = c (mod n),将e分解至只剩质数如：k*e/k，之后将m^e =  m ^(ke/k),将m转换成M = m^k,题目变成求解M，最后将M开方求m。</p><p>​        今天就到这里了，之后的题目提醒了有点难了，就明天再看吧，早点睡觉。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>计算机系统基础(2)</title>
      <link href="/2022/07/19/ji-suan-ji-xi-tong-ji-chu-2/"/>
      <url>/2022/07/19/ji-suan-ji-xi-tong-ji-chu-2/</url>
      
        <content type="html"><![CDATA[<h1 id="计算机系统基础-2"><a href="#计算机系统基础-2" class="headerlink" title="计算机系统基础(2)"></a>计算机系统基础(2)</h1><h3 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h3><p>​        计算机中表示浮点数，</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>计算机系统基础(1)</title>
      <link href="/2022/07/19/ji-suan-ji-xi-tong-ji-chu-1/"/>
      <url>/2022/07/19/ji-suan-ji-xi-tong-ji-chu-1/</url>
      
        <content type="html"><![CDATA[<h1 id="计算机系统基础（1）"><a href="#计算机系统基础（1）" class="headerlink" title="计算机系统基础（1）"></a>计算机系统基础（1）</h1><h3 id="冯诺依曼结构的主要思想："><a href="#冯诺依曼结构的主要思想：" class="headerlink" title="冯诺依曼结构的主要思想："></a>冯诺依曼结构的主要思想：</h3><p>​       1.计算机最少应有 <strong>运算器 控制器 存储器 输入设备和输出设备</strong> </p><p>​       各组件功能：<br>​        存储器 ： 存放数据和指令，二者在形式上没有区别，都是01序列。<br>​        控制器： 自动取出指令并执行<br>​        运算器：有基本的运算功能，逻辑运算和附加运算<br>​        输入和输出设备：完成操作者和计算机的通信<br>​        2.计算机采用<strong>存储程序</strong>的工作方式<br>​            任何计算机完成的工作应先被编写成程序，然后将程序和原始数据送入主存并启动执行<br>​        3.计算机工作的过程：<br>​            程序和数据先由输入设备输入至存储器，存储器将得到的程序中的指令和数据所在的地址逐条给到控制器，控制器执行命令，控制运算器从存储器中读取数据所在的地址，并进行运算，得到的结果仍交到存储器中，最后由存储器交到输出设备上，再由输出设备进行输出。<br>​             整个过程突出一个各司其职。</p><h3 id="现代计算机结构"><a href="#现代计算机结构" class="headerlink" title="现代计算机结构"></a>现代计算机结构</h3><p>​        现代计算机和冯诺依曼结构基本相似，只是更加细分，引入寄存器的部件以方便功能的实现。<br>​        整个程序的执行过程就是控制器根据指令取数据，处理数据，放置数据，指令和数据都在存储器中。CPU必须在寄存器中加载数据才能执行。即<strong>首先根据PC从内存中获取指令对应地址的数据，然后将其保存在IR中，然后控制单元会对指令内容进行判断，并调用寄存器、ALU等执行指令内容，然后更新PC，使其指向下一个要执行的指令地址。</strong><br>​        抽象如下图  MAR和MDR看做是CPU和存储器通讯的硬件。<br><img src="/2022/07/19/ji-suan-ji-xi-tong-ji-chu-1/blog\source_posts\计算机系统基础-1\2.png"></p><h3 id="程序的开发到执行"><a href="#程序的开发到执行" class="headerlink" title="程序的开发到执行"></a>程序的开发到执行</h3><p>​        计算机只认识0/1序列，所以要将高级语言编译或解释为机器语言才能执行。编译是一步步完成的，高级语言被预处理之后开始进行汇编语言的转化，最后变为机器语言，然后变成控制信号，这是表象。深层的是计算机通过自己的软件系统(语言处理系统和操作系统)将你的高级语言转化成0/1序列然后开始执行。</p><h3 id="ISA"><a href="#ISA" class="headerlink" title="ISA"></a>ISA</h3><p>​        指令系统，规定了微体系结构中的各个指令，规定了软件对于硬件的控制的方式。</p><h3 id="信息的二进制编码"><a href="#信息的二进制编码" class="headerlink" title="信息的二进制编码"></a>信息的二进制编码</h3><p>​        机器级的数据分为两大类，以有无数值为标志。以16比特为一个单位在内存中存储。<br>​        有数值的包括<strong>整数和浮点数，有正负之分</strong>，无数值的则是<strong>逻辑运算符或是字符</strong>，这些数据最终都是要变成0和1的。整个计算机中浮点数和定点数都是研究定点数的过程，浮点数可以转化成一个定点整数和一个顶点小数，定点整数确定小数点的位置。<br>​        定点数的表示方式有1.原码：方便理解，但是在运算和计算机使用的时候不方便，所以现在只有浮点数的尾数还在用。</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
