<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>RSA小学生-3</title>
      <link href="/2022/07/28/rsa-xiao-xue-sheng-3/"/>
      <url>/2022/07/28/rsa-xiao-xue-sheng-3/</url>
      
        <content type="html"><![CDATA[<h1 id="RSA小学生（3）"><a href="#RSA小学生（3）" class="headerlink" title="RSA小学生（3）"></a>RSA小学生（3）</h1><h4 id="RSA34：二项式与公因数"><a href="#RSA34：二项式与公因数" class="headerlink" title="RSA34：二项式与公因数"></a>RSA34：二项式与公因数</h4><p>​        本题看似比较难，其实还是之前做过的那几道题的缩影，还是要进行一步步的数学推导想办法将未知的数据求出来。<br>​        </p><p><img src="/2022/07/28/rsa-xiao-xue-sheng-3/001.png"></p><p>​        但是没有e，所以哪怕有p和q也不行，所以现在重新分析，发现h在这里可以当作c进行分析，这里的n先当做e使用。</p><p>​        搞定。</p><h4 id="RSA36："><a href="#RSA36：" class="headerlink" title="RSA36："></a>RSA36：</h4><p>​            首先看出题文件，将每一个变量列出来，发现h1就是dp，这样的话思路想dp泄露方向尝试思考.只是脚本中给了很多无用的信息，应该是相对无用吧，大概是有很多种解法，但我只会这一种。</p><h4 id="RSA37-没有给n"><a href="#RSA37-没有给n" class="headerlink" title="RSA37:没有给n"></a>RSA37:没有给n</h4><p>​        本题没有给n，但是将e和d都给了，并且p和q还是相邻的素数，利用ed应该可以将n爆破出来，注意python中for()语句和if()语句的格式，注意加上break。</p><h4 id="RSA38-模不互素"><a href="#RSA38-模不互素" class="headerlink" title="RSA38:模不互素"></a>RSA38:模不互素</h4><p>​        题中给了两组数据，出去e相同之外，可以根据题目找到n1和n2的公因数，这是p或者是q，结果直接找公因数却是不行，这样思路就直接断了，我当时不太想在这种地方卡时间，就去看了wp，之后才懂这些都是<strong>八进制</strong>的数，所以要先将进制转化过来，</p><p>​        这种题就全靠经验，看不出来死都解不出来。</p><h4 id="RSA39：最大公约数和最小公倍数"><a href="#RSA39：最大公约数和最小公倍数" class="headerlink" title="RSA39：最大公约数和最小公倍数"></a>RSA39：最大公约数和最小公倍数</h4><p>​            这里给出的hint是(p-1)和(q-1)的最小公倍数，这里的hint可以分解所以，hint不等于φ(n)，根据公式<br>​            a*b = gcd(d,b)×lcm(c,b)，这里只能通过位数来判断hint和φ(n)之间的差带盖是多少，发现φ(n)大概等于2到10倍的hint，由此可以开始爆破解题。<br>​            还有就是e不为素数，所以这里还要考虑这一点。</p><h4 id="RSA40："><a href="#RSA40：" class="headerlink" title="RSA40："></a>RSA40：</h4><p>​        这道题就什么好说的了，就很简单了，qp直接出来了，结束。</p><p>结束，撒花，剩下的四道题，呃，等我sagemath学会了再说吧。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>RSA小学生-2</title>
      <link href="/2022/07/25/rsa-xiao-xue-sheng-2/"/>
      <url>/2022/07/25/rsa-xiao-xue-sheng-2/</url>
      
        <content type="html"><![CDATA[<h1 id="RSA小学生-2"><a href="#RSA小学生-2" class="headerlink" title="RSA小学生(2)"></a>RSA小学生(2)</h1><h4 id="RSA19：NC不互素"><a href="#RSA19：NC不互素" class="headerlink" title="RSA19：NC不互素"></a>RSA19：NC不互素</h4><p>​        打开文件文件发现只有n，c和e的数据，之后在看出题脚本，发现c=pow(m×p+n,e,n)，经过推导发现，整个c=pow(m×p,e,n),发现n无法通过yafu分解之后就没有思路了，通过题目的提示，我首先明白了，这道题目的NC是不互素的，所以可以先求NC的公因数，这样可以得到p和q，之后用常规思路开始求解。</p><h4 id="RSA20：Rabin"><a href="#RSA20：Rabin" class="headerlink" title="RSA20：Rabin"></a>RSA20：Rabin</h4><p>​        打开txt文件，发现给的东西挺多的，但是无法运用常规思路求解，只能通过题目下方的提示来看题，进入提示之后发现这是一个新的算法————rabin算法,这是一种RSA的加密方式，它基于一种莫平方和模平方根的非对称加密算法。<br>​        主要的原理是：<br>$$<br>a = x^2 等价于x = √a<br>$$</p><p>$$<br>a=x^2(modm)等价于x=√a(modm)或x = m-√a(modm)<br>$$</p><p>​        加密方式：<br>​        在Rabin算法中默认e=2.所以加密的公式是:<br>$$<br>c = m^2(modn)<br>$$<br>​                其中c为密文，m为明文，n为公钥，n = pq，p，q为私钥，q和p为两个大素数，但满足<br>$$<br>p = q = 3 (mod4)即p和q都是3+4k的形式。<br>$$<br>解密过程的数学思路如下：<br>$$<br>c = m^e(modn)<br>$$</p><p>$$<br>则：c = m^e(modp),c=m^e(modq)[e = 2]<br>$$</p><p>c^(p-1)/2 = m^[(p-1)/2]<em>2=1(modp),代入上式得到c^(p+1)/2 = m^2(modp).<br>        开方得到：<br>$$<br>m1≡c</em>*(p+1)/4(modp)<br>$$</p><p>$$<br>m2≡p-c**(p+1)/4(modp)<br>$$</p><p>$$<br>m3≡c**(q+1)/4(modq)<br>$$</p><p>$$<br>m4≡q-c**(q+1)/4(modq)<br>$$</p><p>​    之后再利用辗转相除法得到yp和yq,使之满足：<br>$$<br>yp∗p+yq∗q=1<br>$$<br>​        这样的话就可以对上述的式子分成4组 (<em>m</em>1,<em>m</em>3),(<em>m</em>2,<em>m</em>3),(<em>m</em>1,<em>m</em>4),(<em>m</em>2,<em>m</em>4) 分别使用中国剩余定理求解，得到4个值，其中一个是明文。设a = yp×p,b = yq×q<br>$$<br>M1≡(a⋅m1+b⋅m3)(modn)<br>$$</p><p>$$<br>M2≡(a⋅m1+b⋅m4)(modn)<br>$$</p><p>$$<br>M3≡(a⋅m2+b⋅m3)(modn)<br>$$</p><p>$$<br>M4≡(a⋅m2+b⋅m4)(modn)<br>$$</p><h4 id="RSA24：PQ的逆元"><a href="#RSA24：PQ的逆元" class="headerlink" title="RSA24：PQ的逆元"></a>RSA24：PQ的逆元</h4><p>​        感觉会很难，题目给出了e，phi，还有PQ相互的逆元，之后开时进行数学推导。<br>$$ {p<em>p1^1 }<br>p</em>p1^1 = 1(modq),则p*p1^1 - 1 = k1q<br>$$</p><p>$$<br>q<em>q1^1 = 1(modp),则q</em>q1^1 - 1 = k2p<br>$$</p><p>$$<br>则两式相乘得到了：q<em>q1^1</em>p<em>p1^1-q</em>q1^1-p*p1^1 + 1 = k1k2qp<br>$$</p><p>$$<br>则：q<em>q1^1+p</em>p1^1 - 1 = (q1^1*p1^1-k1k2)qp<br>$$</p><p>$$<br>q<em>q1^1+p</em>q1^1 - 1 = kn<br>$$</p><p>​        之后有了这个式子之后可以开始求解了，这个主要开始看q，p，n的位数来求解k的范围进行爆破，因为出题脚本已经告诉了p和q是1024bit了，所以n应该是2048bit，然后再看给的q1^1和q1^1分别都是1022bit和1024bit，所以上式的左边应该也是2048bit，这样的话k应该是&lt;2的，所以k = 1。<br>$$<br>φ(n) = (p-1)*(q-1) = pq-p-q+1<br>$$<br>​        这样的话可以用解方程的方式来解出p和q。<br>​        可以使用sympy库中的函数进行解方程。</p><pre class="language-none"><code class="language-none">import sympyp, q = sympy.symbols('p q')//对于未知数的初始化，将其转变为python可以解读的变量expr1 = pinv * p + qinv * q - 1 - p*q//方程组式子1expr2 = (p-1)*(q-1) - phi//方程组式子2r = sympy.solve([expr1,expr2],[p, q])//求解方程</code></pre><h4 id="RSA25-共模攻击变形-共模攻击-ec不共素"><a href="#RSA25-共模攻击变形-共模攻击-ec不共素" class="headerlink" title="RSA25:共模攻击变形(共模攻击+ec不共素)"></a>RSA25:共模攻击变形(共模攻击+ec不共素)</h4><p>​        题中和往常的共模攻击脚本一样，给了该给的数据，先重新使用共模攻击思路开始求解试试，结果确实乱码，所以我尝试转变思路，尝试分解n，结果n无法分解，之后再次转变思路，发现两个e好像不是素数，存在一个公共的因数，这里就可以联想到之前的ce不共素上了，可以直接解题试试，思路和共模攻击基本相同。</p><h4 id="RSA26："><a href="#RSA26：" class="headerlink" title="RSA26："></a>RSA26：</h4><p>​        和上面的25题基本一致，补充一下上面的题目和本题的另一个重点，在共模攻击之后解出c1^s1+c2^s2之后，c1^s1+c2^s2实际上是M + k*n,所以之后的开根，要进行一次for循环，将k爆破。</p><h4 id="RSA27：费马小定理"><a href="#RSA27：费马小定理" class="headerlink" title="RSA27：费马小定理"></a>RSA27：费马小定理</h4><p>​        看题目之后，明白了本题主要考察的是费马小定理，之后在研究出题脚本。，发现给了n，c，e还有hint，首先尝试分解n，失败之后，开始推导数学公式，推导过程如下：<br>$$<br>h = (2020^p+2021)^qmod(n)<br>$$</p><p>$$<br>h = (2020⋅p)^q+(2020⋅p)^q−1⋅2021+⋯+2021^q+kpq<br>$$</p><p>$$<br>h = 2021^q+kp,则h = 2021^q(modp)<br>$$</p><p>​        之后可以介入费马小定理， a^p<em>≡</em>a*(mod<em>p</em>)<br>$$<br>h = 2021^q(modp)=(2021^q)^p (modp)<br>$$</p><p>$$<br>h = 2021^n+kp<br>$$<br>​        由此可以将利用h-2021^n或2021^n-h(主要是看两者的大小比较)p求出来，另外2021^n太大，运算起来太麻烦，可以pow(2021,n,n)来代替。</p><h4 id="RSA28-费马（2）"><a href="#RSA28-费马（2）" class="headerlink" title="RSA28:费马（2）"></a>RSA28:费马（2）</h4><p>​        本题和上面的题目也是大概一致，都是与公约数的求解有关，本题的思路是。<br>$$<br>hc = h +kp<br>$$</p><h4 id="RSA29-数论"><a href="#RSA29-数论" class="headerlink" title="RSA29:数论"></a>RSA29:数论</h4><p>​            整个题目给出的数据有限，只能开始进行数学推导，推到完成后，我整理了一下，大概思路如下：<br>​            过程用键盘敲出来太麻烦了，我直接上草纸了：<br><img src="/2022/07/25/rsa-xiao-xue-sheng-2/001.png"></p><h4 id="RSA30：方程"><a href="#RSA30：方程" class="headerlink" title="RSA30：方程"></a>RSA30：方程</h4><p>​        很简单的方程解法，甚至不用方程就可以解出答案，唯一的问题是我自己代码敲得太不熟练了。</p><h4 id="RSA31："><a href="#RSA31：" class="headerlink" title="RSA31："></a>RSA31：</h4><p>​        这题没什么难的，思路都很简单，只是第一次做的时候基本上是做不出来的，需要一定的经验，主要是最后的m要注意将其从十进制转字符，这个就只能作为一种经验了，得记好。</p><pre class="language-none"><code class="language-none">import libnumdef decipher_rsa(p,q,n,e,c):    """RSA 解密函数    """    phi = (p-1)*(q-1)    assert(libnum.gcd(e,phi) == 1)    d = libnum.invmod(e,phi)    m = pow(c, d, n)    print(m)    print(libnum.n2s(m))    return mm = decipher_rsa(p,q,n,e,c)i = 0s = str(m)flag = ""while i &lt; len(s):    if int(s[i:i+3]) &lt; 128:        flag += chr(int(s[i:i+3]))        i += 3    else:        flag += chr(int(s[i:i+2]))        i += 2print(flag)</code></pre><h4 id="RSA32："><a href="#RSA32：" class="headerlink" title="RSA32："></a>RSA32：</h4><p>​        这道题挺简单的，思路也挺多的，主要是p和q是相邻的两个素数。</p><h4 id="RSA34："><a href="#RSA34：" class="headerlink" title="RSA34："></a>RSA34：</h4><h4 id="RSA35"><a href="#RSA35" class="headerlink" title="RSA35:"></a>RSA35:</h4><p>​        C的算法就是中国剩余定理，可以直接解出来，n的话不能分解，但是p和q是相邻的素数。<br>明天应该就可以做完了，去刷别的平台了。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>RSA小学生(1)</title>
      <link href="/2022/07/21/rsa-xiao-xue-sheng-1/"/>
      <url>/2022/07/21/rsa-xiao-xue-sheng-1/</url>
      
        <content type="html"><![CDATA[<h1 id="RSA小学生-1"><a href="#RSA小学生-1" class="headerlink" title="RSA小学生(1)"></a>RSA小学生(1)</h1><p>​        这是我之前发现的一个网站，里面是一个大佬原创的一系列RSA基础题目。<br>​        网址：<a href="http://162.14.73.60:18000/challenges">http://162.14.73.60:18000/challenges</a></p><h4 id="RSA1：普通题目"><a href="#RSA1：普通题目" class="headerlink" title="RSA1：普通题目"></a>RSA1：普通题目</h4><p>​        题目给出了出题的脚本，关键是e = 1，根据rsa的加密解密公式:m^e = c (mod n),可以得到这里的m = c,所以可以直接得到答案。</p><h4 id="RSA2-m-gt-n"><a href="#RSA2-m-gt-n" class="headerlink" title="RSA2: m > n"></a>RSA2: m &gt; n</h4><p>​        题目中还是e = 1,所以处理方式还是和上面的一样，但是结果却出了一堆乱码，所以说明了这次的m是大于n的，但是尝试爆破，很难爆破出来，所以有别的思路，用中国剩余定理可以得到m。<br>​        中国剩余定理的函数在python可以自己写.</p><pre class="language-none"><code class="language-none">from functools import reducedef CRT(mi, ai):    # mi,ai分别表示模数和取模后的值,都为列表结构    # Chinese Remainder Theorem    assert (isinstance(mi, list) and isinstance(ai, list))    M = reduce(lambda x, y: x * y, mi)    ai_ti_Mi = [a * (M // m) * gmpy2.invert(M // m, m) for (m, a) in zip(mi, ai)]    return reduce(lambda x, y: x + y, ai_ti_Mi) % M</code></pre><h4 id="RSA3-共模攻击"><a href="#RSA3-共模攻击" class="headerlink" title="RSA3: 共模攻击"></a>RSA3: 共模攻击</h4><p>​        题目中给了两组公钥和密文，因为n两组n相等，所以首先判断是共模攻击，数学思想为：<br>$$<br>证明: m = c1^s1 *c2^s2%n<br>$$</p><p>$$<br>m = c^d (mod n)<br>$$</p><p>$$<br>c1 = m^e1( mod n)<br>$$</p><p>$$<br>c2 = m^e2( mod n)<br>$$</p><p>$$<br>得：c1^s1 <em>c2^s2//n = [(m^e1)^s1//n</em>(m^e2)^s2//n]//n<br>$$</p><p>$$<br>化简得: c1^s1 <em>c2^s2%n = [(m^e1)^s1</em>(m^e2)^s2]%n<br>                      = [(m^e1s1+e2s2]%n<br>                      = m%n<br>                      = m<br>$$</p><p>​        s由拓展欧几里得得到，满足e1s1+e2s2 = gcd(e1,e2)</p><h4 id="RSA4-enc文件"><a href="#RSA4-enc文件" class="headerlink" title="RSA4: .enc文件"></a>RSA4: .enc文件</h4><p>​        题目给了两个压缩包，格式都是.enc，所以在python中用open(,’rb’)read()将其打开解读，拿到了n,e,c尝试分解n，不成功，看到题目，尝试将c分解，成功了，所以c和n互换，开始解题，结果出错了，再看题，给错密钥了，尝试直接将d打印出来，成功了.</p><h4 id="RSA5"><a href="#RSA5" class="headerlink" title="RSA5:"></a>RSA5:</h4><p>​        和第四题一样将文件解读出来，使用yafu将n分解，得到flag。</p><h4 id="RSA6-OEAP填充的-enc文件"><a href="#RSA6-OEAP填充的-enc文件" class="headerlink" title="RSA6: OEAP填充的.enc文件"></a>RSA6: OEAP填充的.enc文件</h4><p>​        题目名称是听说过OEAP吗，这是一种对于密文的填充方式，需要新的函数解读。还是先想之前的一样，将文件打开，找到公钥，并用yafu将n分解得到p和q之后开始正常解题，结果果然还是不行，于是开始再次解读c。<br>​        引入</p><pre class="language-none"><code class="language-none">import Crypto.Cipher.PKCS1_OAEP as OAEPkey = RSA.construct((p*q,e,int(gmpy2.invert(e,phi))))rsa = OAEP.new(key)print(rsa.decrypt(c))</code></pre><p>​        完成对于密文的解密。</p><h4 id="RSA7：维纳攻击"><a href="#RSA7：维纳攻击" class="headerlink" title="RSA7：维纳攻击"></a>RSA7：维纳攻击</h4><p>​        题中很明显的一个特点是e很大，参考维纳攻击，可以完成爆破。<br>​        维纳攻击主要是依靠连分数和渐进分数，主要数学思想如下<br>$$<br>p和q是很大的素数，则(p-1)<em>(q-1)无限趋近于p</em>q.<br>$$</p><p>$$<br>ed = 1 (mod φ(n))<br>$$</p><p>$$<br>ed = kφ(n) + 1,两边同时除以dφ(n)得到：<br>$$</p><p>$$<br>e/φ(n) = k/d +1/dφ(n)<br>$$</p><p>$$<br>≈ e/n = k/d +1/dφ(n)<br>$$</p><p>$$<br>所以k/d一定在是e/n的渐进分数之一,之后可以将d爆破出来<br>$$</p><h4 id="RSA8"><a href="#RSA8" class="headerlink" title="RSA8:"></a>RSA8:</h4><p>​        奇怪的N？N怪在哪里，不知道，但还是先将其分解试试，明白了，N奇怪在不可分解，但这样就没有思路了，题目只给了n，e，c，所以我尝试将n直接当成q*1来使用，也就是说q = n,p = 1，最终解出答案。</p><h4 id="RSA9："><a href="#RSA9：" class="headerlink" title="RSA9："></a>RSA9：</h4><p>​        说好了，摊牌了，所以我就直接试了试，结果除了一堆乱码，又想到他说的摊牌可能是直接将明文给出来了，所以我要找下c，结果确实，他摊牌了，啥都招了。</p><h4 id="RSA10：多组p-q-c"><a href="#RSA10：多组p-q-c" class="headerlink" title="RSA10：多组p,q,c"></a>RSA10：多组p,q,c</h4><p>​        这道题给了两组数据，没有什么关联的，所以这道题应该是让我去找关联。尝试进行数学分析。先尝试直接求解，结果出了一堆乱码，再尝试使用中国剩余定理，结果还是一堆乱码，继续转变思路，尝试将两组数据当成一组处理，只是这样的话，可以得到除了明文和密文之外的所有数据，但需重新找到c，这里可以使用中国剩余定理，最终结出明文。</p><h4 id="RSA11：e很小"><a href="#RSA11：e很小" class="headerlink" title="RSA11：e很小"></a>RSA11：e很小</h4><p>​        题目中e = 3，先想到爆破，最终爆破出答案。</p><h4 id="RSA12："><a href="#RSA12：" class="headerlink" title="RSA12："></a>RSA12：</h4><p>​        题目中给出中国剩余定理的提示，但又在问e是多少，所以这道题应该是要将e爆破出来的,题目给出了e的范围是（10，20），e为素数所以也很好爆破。</p><pre class="language-none"><code class="language-none">def CRT(mi, ai):    assert(reduce(gmpy2.gcd,mi)==1)    assert (isinstance(mi, list) and isinstance(ai, list))    M = reduce(lambda x, y: x * y, mi)    ai_ti_Mi = [a * (M // m) * gmpy2.invert(M // m, m) for (m, a) in zip(mi, ai)]    return reduce(lambda x, y: x + y, ai_ti_Mi) % M</code></pre><h4 id="RSA13：两组N之间存在公因数p"><a href="#RSA13：两组N之间存在公因数p" class="headerlink" title="RSA13：两组N之间存在公因数p"></a>RSA13：两组N之间存在公因数p</h4><p>​        本题给了两组N和C也给了e，根据出题的脚本，两组N之间存在一个公因数p，可以现将p和q1，q2求出来，最终得到了两组数据，分别求解，c1和c2分别是flag的一半。</p><h4 id="RSA14：dp泄露"><a href="#RSA14：dp泄露" class="headerlink" title="RSA14：dp泄露"></a>RSA14：dp泄露</h4><p>​        dp泄露，给出了e，解题的数学思想如下：<br>$$<br>dp = d (mod (p-1))<br>$$</p><p>$$<br>edp = ed (mod(p-1))<br>$$</p><p>$$<br>ed = 1 (modφ(n))<br>$$</p><p>$$<br>ed = 1(mod(p-1))<br>$$</p><p>$$<br>edp = 1(mod(p-1))<br>$$</p><p>$$<br>edp - 1 = k(p-1)<br>$$</p><p>$$<br>2^(edp-1) = 2^k(p-1)=1(modp)<br>$$</p><p>$$<br>2^(edp-1) - 1 = tp<br>$$</p><p>$$<br>所以2^(edp-1) - 1和n之间存在公因数p，p可以直接求出来。<br>$$</p><p>​        也可以通过爆破k的方式来求解p，具体是edp&gt;k(p-1),dp&lt;p-1,e&gt;k.依靠函数libnum.prime_test()判断p是否为素数，来达到目的。</p><h4 id="RSA15：dp和dq同时泄露"><a href="#RSA15：dp和dq同时泄露" class="headerlink" title="RSA15：dp和dq同时泄露"></a>RSA15：dp和dq同时泄露</h4><p>​        dp和dq泄露，都有但是没有e所以思路应该和上面拿到题有所区别，数学思路如下：<br>$$<br>m = c^d (mod n)<br>$$</p><p>$$<br>设mp = c^d(mod p),mq = c^d(modq)<br>$$</p><p>$$<br>dp = d(mod(p-1),dq = d(mod(p-1)<br>$$</p><p>$$<br>所以dp = d + k(p-1),dq = d + k(q-1)<br>$$</p><p>$$<br>c^d = c^dp(mod n),c^d = c^dq(mod n)<br>$$</p><p>$$<br>c^d = mp + tp<br>$$</p><p>$$<br>mq = (mp+tp) (modq)<br>$$</p><p>$$<br>mq - mp = tp(modq)<br>$$</p><p>$$<br>(mq-mp)p^-1 = t (modq)<br>$$</p><p>$$<br>t = (mq-mp)p^-1  (modq)<br>$$</p><p>$$<br>则c^d = mp + ((mq-mp)p^-1  (modq))<br>$$</p><p>$$<br>m = mp + p*((mq-mp)p^-1  (modq))(mod n)<br>$$</p><p>​        右边的数据全部已知，所以m就已知。</p><h4 id="RSA16：n为一个素数的x次方，欧拉函数的求法"><a href="#RSA16：n为一个素数的x次方，欧拉函数的求法" class="headerlink" title="RSA16：n为一个素数的x次方，欧拉函数的求法"></a>RSA16：n为一个素数的x次方，欧拉函数的求法</h4><p>​        题目让分解n，那就先用yafu分解n试试，结果出了5个因数，但还是按常规思路去解题。结果却是乱码，再次仔细看题目，发现n分解的5个因数全部相等，那么n的欧拉函数的求解就要用别的方法了。<br>欧拉定理:<br>$$<br>1.当n为1时，φ(1)=1。因为1与任何数都构成互质关系<br>$$</p><p>$$<br>2.当n为质数时，φ(n)=n−1。因为质数与小于它的每一个数都互质。<br>$$</p><p>$$<br>3.当n为质数的次方时n=p^k，则φ(n)=p^k−p^(k−1)=p^(k-1)*(p-1).<br>$$</p><p>$$<br>4.当n为两个互质的数之积n=p⋅q, 则φ(n)=φ(p)φ⋅(q).<br>$$</p><p>$$<br>5.任意一个大于1的正整数n，都可以写成一系列质数的积n=p^k1*p^k2⋯p^kr<br>$$</p><h4 id="RSA17"><a href="#RSA17" class="headerlink" title="RSA17:"></a>RSA17:</h4><p>​        好像什么都说了，但尝试将q解出来后，发现q不是素数，将q分解后发现q可以分解成3个相等的因数，所以这道题又回到了φ(n)的求解上来了，明白了这些之后，flag就直接出来了。</p><h4 id="RSA18：e不为素数"><a href="#RSA18：e不为素数" class="headerlink" title="RSA18：e不为素数"></a>RSA18：e不为素数</h4><p>​        题目有问题，什么问题？e好像不是素数，处理的方式和之前思想相同，m^e = c (mod n),将e分解至只剩质数如：k*e/k，之后将m^e =  m ^(ke/k),将m转换成M = m^k,题目变成求解M，最后将M开方求m。</p><p>​        今天就到这里了，之后的题目提醒了有点难了，就明天再看吧，早点睡觉。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>计算机系统基础(2)</title>
      <link href="/2022/07/19/ji-suan-ji-xi-tong-ji-chu-2/"/>
      <url>/2022/07/19/ji-suan-ji-xi-tong-ji-chu-2/</url>
      
        <content type="html"><![CDATA[<h1 id="计算机系统基础-2"><a href="#计算机系统基础-2" class="headerlink" title="计算机系统基础(2)"></a>计算机系统基础(2)</h1><h3 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h3><p>​        计算机中表示浮点数，</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>计算机系统基础(1)</title>
      <link href="/2022/07/19/ji-suan-ji-xi-tong-ji-chu-1/"/>
      <url>/2022/07/19/ji-suan-ji-xi-tong-ji-chu-1/</url>
      
        <content type="html"><![CDATA[<h1 id="计算机系统基础（1）"><a href="#计算机系统基础（1）" class="headerlink" title="计算机系统基础（1）"></a>计算机系统基础（1）</h1><h3 id="冯诺依曼结构的主要思想："><a href="#冯诺依曼结构的主要思想：" class="headerlink" title="冯诺依曼结构的主要思想："></a>冯诺依曼结构的主要思想：</h3><p>​       1.计算机最少应有 <strong>运算器 控制器 存储器 输入设备和输出设备</strong> </p><p>​       各组件功能：<br>​        存储器 ： 存放数据和指令，二者在形式上没有区别，都是01序列。<br>​        控制器： 自动取出指令并执行<br>​        运算器：有基本的运算功能，逻辑运算和附加运算<br>​        输入和输出设备：完成操作者和计算机的通信<br>​        2.计算机采用<strong>存储程序</strong>的工作方式<br>​            任何计算机完成的工作应先被编写成程序，然后将程序和原始数据送入主存并启动执行<br>​        3.计算机工作的过程：<br>​            程序和数据先由输入设备输入至存储器，存储器将得到的程序中的指令和数据所在的地址逐条给到控制器，控制器执行命令，控制运算器从存储器中读取数据所在的地址，并进行运算，得到的结果仍交到存储器中，最后由存储器交到输出设备上，再由输出设备进行输出。<br>​             整个过程突出一个各司其职。</p><h3 id="现代计算机结构"><a href="#现代计算机结构" class="headerlink" title="现代计算机结构"></a>现代计算机结构</h3><p>​        现代计算机和冯诺依曼结构基本相似，只是更加细分，引入寄存器的部件以方便功能的实现。<br>​        整个程序的执行过程就是控制器根据指令取数据，处理数据，放置数据，指令和数据都在存储器中。CPU必须在寄存器中加载数据才能执行。即<strong>首先根据PC从内存中获取指令对应地址的数据，然后将其保存在IR中，然后控制单元会对指令内容进行判断，并调用寄存器、ALU等执行指令内容，然后更新PC，使其指向下一个要执行的指令地址。</strong><br>​        抽象如下图  MAR和MDR看做是CPU和存储器通讯的硬件。<br><img src="/2022/07/19/ji-suan-ji-xi-tong-ji-chu-1/blog\source_posts\计算机系统基础-1\2.png"></p><h3 id="程序的开发到执行"><a href="#程序的开发到执行" class="headerlink" title="程序的开发到执行"></a>程序的开发到执行</h3><p>​        计算机只认识0/1序列，所以要将高级语言编译或解释为机器语言才能执行。编译是一步步完成的，高级语言被预处理之后开始进行汇编语言的转化，最后变为机器语言，然后变成控制信号，这是表象。深层的是计算机通过自己的软件系统(语言处理系统和操作系统)将你的高级语言转化成0/1序列然后开始执行。</p><h3 id="ISA"><a href="#ISA" class="headerlink" title="ISA"></a>ISA</h3><p>​        指令系统，规定了微体系结构中的各个指令，规定了软件对于硬件的控制的方式。</p><h3 id="信息的二进制编码"><a href="#信息的二进制编码" class="headerlink" title="信息的二进制编码"></a>信息的二进制编码</h3><p>​        机器级的数据分为两大类，以有无数值为标志。以16比特为一个单位在内存中存储。<br>​        有数值的包括<strong>整数和浮点数，有正负之分</strong>，无数值的则是<strong>逻辑运算符或是字符</strong>，这些数据最终都是要变成0和1的。整个计算机中浮点数和定点数都是研究定点数的过程，浮点数可以转化成一个定点整数和一个顶点小数，定点整数确定小数点的位置。<br>​        定点数的表示方式有1.原码：方便理解，但是在运算和计算机使用的时候不方便，所以现在只有浮点数的尾数还在用。</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
